# -*- coding: utf-8 -*-
#  Copyright (c) 2019-2021 Ivan LUCAS.
#  Noethysweb, application de gestion multi-activités.
#  Distribué sous licence GNU GPL.

import datetime
from django.db.models import Q
from django.urls import reverse_lazy
from core.models import Famille, Individu, Piece, TypePiece, Inscription, Rattachement
from core.utils import utils_texte


import datetime
from core.models import Piece

def Get_pieces_manquantes_individu(famille=None, individu=None, activite=None, date_reference=None):
    """
    Retourne les pièces manquantes pour un individu sur une activité donnée.

    Args:
        famille: instance Famille
        individu: instance Individu
        activite: instance Activite
        date_reference: date de référence pour la validité des pièces (optionnel)

    Returns:
        liste de dictionnaires:
        [
            {
                "type_piece": <TypePiece>,
                "label": <nom de la pièce>,
                "valide": True/False,
                "document": <document lié ou None>
            },
            ...
        ]
    """
    if not date_reference:
        date_reference = datetime.date.today()

    # Récupère toutes les pièces existantes pour la famille et l'individu
    pieces_existantes = Piece.objects.select_related("type_piece").filter(
        famille=famille,
        individu=individu,
        date_debut__lte=date_reference,
        date_fin__gte=date_reference
    )

    # Dictionnaire pour lookup rapide
    dict_pieces = {}
    for piece in pieces_existantes:
        key = (piece.type_piece_id, piece.individu_id or 0)
        dict_pieces[key] = piece

    # Vérifie toutes les pièces requises par l'activité
    pieces_necessaires = []
    for type_piece in activite.pieces.all():
        # Vérifie si la pièce est valide
        valide = False
        if type_piece.public == "famille":
            # Pièce demandée pour la famille
            for piece in pieces_existantes:
                if piece.type_piece_id == type_piece.pk and piece.famille_id == famille.pk and piece.date_fin >= date_reference:
                    valide = True
        else:
            # Pièce demandée pour l'individu
            for piece in pieces_existantes:
                if piece.type_piece_id == type_piece.pk and piece.individu_id == individu.pk and piece.date_fin >= date_reference:
                    valide = True

        pieces_necessaires.append({
            "type_piece": type_piece,
            "label": type_piece.Get_nom(individu),
            "valide": valide,
            "document": type_piece.type_piece_document.first() if type_piece.type_piece_document.exists() else None
        })

    # Retourne uniquement les pièces manquantes
    return [p for p in pieces_necessaires if not p["valide"]]


def Get_pieces_manquantes(famille=None, date_reference=None, only_invalides=False, utilisateur=None, exclure_individus=[]):
    """ Retourne les pièces manquantes d'une famille """
    if not date_reference:
        date_reference = datetime.date.today()

    # Conditions SQL
    conditions = Q(activite__visible=True) & Q(famille=famille) & Q(individu__deces=False) & (Q(date_fin__isnull=True) | Q(date_fin__gte=date_reference) )
    if utilisateur:
        conditions &= Q(activite__structure__in=utilisateur.structures.all())

    # Lecture de la db
    inscriptions = Inscription.objects.select_related('activite', 'individu', 'activite__structure').prefetch_related('activite__pieces').filter(conditions).exclude(individu__in=exclure_individus)
    pieces_existantes = Piece.objects.select_related('type_piece').filter(Q(famille=famille) | Q(individu__in=[i.individu_id for i in inscriptions]))

    liste_traitees = []
    liste_resultats = []
    for inscription in inscriptions:
        for type_piece in inscription.activite.pieces.all():

            # Vérifie si la pièce existe
            valide = False
            for piece in pieces_existantes:
                if piece.type_piece_id == type_piece.pk and piece.date_fin >= date_reference:
                    if type_piece.public == "famille":
                        valide = True
                    if type_piece.public == "individu" and piece.individu_id == inscription.individu_id:
                        if type_piece.valide_rattachement == True:
                            valide = True
                        elif piece.famille_id == inscription.famille_id:
                            valide = True

            # Création du lien de création
            if valide:
                href = None
            else:
                href = None

            # Mémorise la pièce à fournir
            dict_temp = {
                "label": type_piece.Get_nom(inscription.individu),
                "valide": valide,
                "type_piece": type_piece,
                "titre": "Cliquez ici pour créer immédiatement cette pièce",
                "href": href,
            }
            if type_piece.public == "famille":
                dict_temp["individu"] = None
                temp = (type_piece, None)
            else:
                dict_temp["individu"] = inscription.individu
                temp = (type_piece, inscription.individu)
            if temp not in liste_traitees and (only_invalides == False or valide == False):
                liste_traitees.append(temp)
                liste_resultats.append(dict_temp)

    return liste_resultats


def Get_liste_pieces_manquantes(date_reference=None, activites=None, presents=None, only_concernes=True, liste_familles=[]):
    """ Retourne les pièces manquantes d'un ensemble de familles inscrites ou présentes """
    if not date_reference:
        date_reference = datetime.date.today()
    # Importation des inscriptions
    conditions = Q()
    if activites:
        conditions &= Q(activite__in=activites)
    if presents:
        conditions &= Q(consommation__date__gte=presents[0], consommation__date__lte=presents[1])
    if liste_familles:
        conditions &= Q(famille__in=liste_familles)
    inscriptions = Inscription.objects.select_related('activite', 'individu', 'famille').prefetch_related('activite__pieces').filter(conditions).distinct()

    # Importation des pièces existantes
    conditions = Q(date_debut__lte=date_reference) & Q(date_fin__gte=date_reference)
    pieces_existantes = Piece.objects.select_related('type_piece').filter(conditions)

    dict_pieces = {}
    for piece in pieces_existantes:
        if piece.type_piece:
            if piece.type_piece.public == "famille" and piece.famille_id:
                key = "famille_%d_%d" % (piece.famille_id, piece.type_piece_id)
            elif piece.type_piece.public == "individu" and piece.individu_id:
                key = "individu_%d_%d" % (piece.individu_id, piece.type_piece_id)
            else:
                key = None
            if key:
                dict_pieces.setdefault(key, [])
                dict_pieces[key].append(piece)
    liste_traitees = []
    dict_resultats = {}
    for inscription in inscriptions:
        dict_resultats.setdefault(inscription.famille, [])

        for type_piece in inscription.activite.pieces.all():
            # Vérifie si la pièce existe
            valide = False
            if type_piece.public == "famille":
                key = "famille_%d_%d" % (inscription.famille_id, type_piece.pk)
            else:
                key = "individu_%d_%d" % (inscription.individu_id, type_piece.pk)
            for piece in dict_pieces.get(key, []):
                if type_piece.public == "famille" and piece.famille_id == inscription.famille_id:
                    valide = True
                if type_piece.public == "individu" and piece.individu_id == inscription.individu_id:
                    if type_piece.valide_rattachement == True:
                        valide = True
                    elif piece.famille_id == inscription.famille_id:
                        valide = True

            # Création du lien de création
            if valide:
                href = None
            else:
                href = None
            # Mémorise la pièce à fournir
            dict_temp = {
                "label": type_piece.Get_nom(inscription.individu),
                "valide": valide,
                "type_piece": type_piece,
                "titre": "Cliquez ici pour créer immédiatement cette pièce",
                "href": href,
            }
            if type_piece.public == "famille":
                dict_temp["individu"] = None
                temp = (type_piece, None, inscription.famille_id)
            else:
                dict_temp["individu"] = inscription.individu
                temp = (type_piece, inscription.individu, inscription.famille_id)
            if temp not in liste_traitees and not valide:
                liste_traitees.append(temp)
                dict_resultats[inscription.famille].append(dict_temp)
    # Tri et filtre des résultats
    dict_final = {}
    for famille, liste_pieces in dict_resultats.items():
        if not only_concernes or liste_pieces:
            liste_pieces = sorted(liste_pieces, key=lambda x: x["label"])
            texte = utils_texte.Convert_liste_to_texte_virgules([x["label"] for x in liste_pieces])
            dict_final[famille.pk] = {"texte": texte, "nbre": len(liste_pieces), "liste": liste_pieces, "nom_famille": famille.nom}

    return dict_final


def Get_pieces_manquantes_par_inscriptions(inscriptions, date_reference=None):
    """
    Retourne les pièces manquantes pour une liste d'inscriptions de manière optimisée.
    Fait seulement 2 requêtes DB au total au lieu d'une par inscription.

    Args:
        inscriptions: QuerySet ou liste d'instances Inscription (déjà avec select_related/prefetch_related)
        date_reference: date de référence pour la validité des pièces (optionnel)

    Returns:
        dict[individu.pk] -> liste de dictionnaires de pièces manquantes:
        {
            123: [  # individu.pk
                {
                    "type_piece": <TypePiece>,
                    "label": <nom de la pièce>,
                    "valide": False,
                    "document": <document lié ou None>
                },
                ...
            ],
            ...
        }
    """
    if not date_reference:
        date_reference = datetime.date.today()

    # Convertir en liste si c'est un QuerySet pour éviter les multiples évaluations
    inscriptions_list = list(inscriptions)
    
    if not inscriptions_list:
        return {}

    # Extraire tous les IDs nécessaires
    famille_ids = set(ins.famille_id for ins in inscriptions_list)
    individu_ids = set(ins.individu_id for ins in inscriptions_list)

    # Récupération optimisée : 1 requête pour les pièces + 1 pour les type_pieces requis par activités
    conditions = Q(date_debut__lte=date_reference) & Q(date_fin__gte=date_reference)
    conditions &= Q(famille_id__in=famille_ids) & (Q(individu_id__isnull=True) | Q(individu_id__in=individu_ids))
    
    pieces_existantes = Piece.objects.select_related("type_piece").filter(conditions)
    
    # Pré-charger tous les documents de type_piece en UNE requête (pour éviter N queries plus tard)
    from core.models import TypePiece
    type_piece_ids = set()
    for inscription in inscriptions_list:
        for type_piece in inscription.activite.pieces.all():  # Déjà prefetché dans le queryset
            type_piece_ids.add(type_piece.pk)
    
    # Dictionnaire de lookup pour les documents
    dict_documents = {}
    if type_piece_ids:
        for type_piece in TypePiece.objects.filter(pk__in=type_piece_ids).prefetch_related('type_piece_document'):
            doc = type_piece.type_piece_document.first()
            if doc:
                dict_documents[type_piece.pk] = doc

    # Construire le dictionnaire de lookup des pièces
    dict_pieces = {}
    for piece in pieces_existantes:
        if piece.type_piece:
            if piece.type_piece.public == "famille" and piece.famille_id:
                key = "famille_%d_%d" % (piece.famille_id, piece.type_piece_id)
            elif piece.type_piece.public == "individu" and piece.individu_id:
                key = "individu_%d_%d" % (piece.individu_id, piece.type_piece_id)
            else:
                continue
            dict_pieces.setdefault(key, [])
            dict_pieces[key].append(piece)

    # Traiter chaque inscription et construire les résultats par individu
    dict_resultats = {}
    
    for inscription in inscriptions_list:
        individu = inscription.individu
        famille = inscription.famille
        activite = inscription.activite
        
        # Initialiser la liste pour cet individu si nécessaire
        if individu.pk not in dict_resultats:
            dict_resultats[individu.pk] = []
        
        # Parcourir les pièces requises par l'activité (déjà prefetch dans le QuerySet)
        for type_piece in activite.pieces.all():
            # Vérifier si la pièce existe et est valide
            valide = False
            
            if type_piece.public == "famille":
                key = "famille_%d_%d" % (famille.pk, type_piece.pk)
                for piece in dict_pieces.get(key, []):
                    if piece.famille_id == famille.pk and piece.date_fin >= date_reference:
                        valide = True
                        break
            else:  # individu
                key = "individu_%d_%d" % (individu.pk, type_piece.pk)
                for piece in dict_pieces.get(key, []):
                    if piece.individu_id == individu.pk and piece.date_fin >= date_reference:
                        if type_piece.valide_rattachement == True:
                            valide = True
                            break
                        elif piece.famille_id == famille.pk:
                            valide = True
                            break
            
            # Ne garder que les pièces NON valides (manquantes)
            if not valide:
                dict_resultats[individu.pk].append({
                    "type_piece": type_piece,
                    "label": type_piece.Get_nom(individu),
                    "valide": False,
                    "document": dict_documents.get(type_piece.pk, None)  # Lookup pré-chargé, pas de requête !
                })
    
    return dict_resultats


def Get_liste_pieces_necessaires(date_reference=None, activite=None, famille=None, individu=None):
    """ Retourne les pièces nécessaires à l'inscription d'un individu sur une activité donnée pour une famille et un individu donné """
    if not date_reference:
        date_reference = datetime.date.today()

    # Importation des pièces existantes de la famille
    dict_pieces = {}
    for piece in Piece.objects.select_related("type_piece").filter(famille=famille, date_debut__lte=date_reference, date_fin__gte=date_reference):
        if piece.type_piece:
            key = "famille_%d_%d" % (piece.famille_id, piece.type_piece_id) if piece.type_piece.public == "famille" else "individu_%d_%d" % (piece.individu_id, piece.type_piece_id)
            dict_pieces.setdefault(key, [])
            dict_pieces[key].append(piece)

    print(dict_pieces)

    liste_pieces_necessaires = []
    for type_piece in activite.pieces.all():
        # Vérifie si la pièce existe
        valide = False
        key = "famille_%d_%d" % (famille.pk, type_piece.pk) if type_piece.public == "famille" else "individu_%d_%d" % (individu.pk, type_piece.pk)
        for piece in dict_pieces.get(key, []):
            if type_piece.public == "famille" and piece.famille_id == famille.pk:
                valide = True
            if type_piece.public == "individu" and piece.individu_id == individu.pk:
                if type_piece.valide_rattachement == True:
                    valide = True
                elif piece.famille_id == famille.pk:
                    valide = True

        liste_pieces_necessaires.append({"type_piece": type_piece, "valide": valide, "document": type_piece.type_piece_document.first()})

    print(liste_pieces_necessaires)

    return liste_pieces_necessaires
